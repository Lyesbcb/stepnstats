{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nexport function base64toBlob(base64Data, contentType) {\n  contentType = contentType || '';\n  var sliceSize = 1024;\n  var byteCharacters = atob(base64Data);\n  var bytesLength = byteCharacters.length;\n  var slicesCount = Math.ceil(bytesLength / sliceSize);\n  var byteArrays = new Array(slicesCount);\n\n  for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\n    var begin = sliceIndex * sliceSize;\n    var end = Math.min(begin + sliceSize, bytesLength);\n    var bytes = new Array(end - begin);\n\n    for (var offset = begin, i = 0; offset < end; ++i, ++offset) {\n      bytes[i] = byteCharacters[offset].charCodeAt(0);\n    }\n\n    byteArrays[sliceIndex] = new Uint8Array(bytes);\n  }\n\n  return new Blob(byteArrays, {\n    type: contentType\n  });\n}\nexport function blobToBase64Async(blob) {\n  return new Promise(function (resolve, _) {\n    var reader = new FileReader();\n\n    reader.onloadend = function () {\n      return resolve(reader.result);\n    };\n\n    reader.readAsDataURL(blob);\n  });\n}\nexport function htmlToPlainText(html) {\n  var tempDivElement = document.createElement('div');\n  tempDivElement.innerHTML = html;\n  return tempDivElement.textContent || tempDivElement.innerText || '';\n}\nexport function getImageSizeFromBlobAsync(blob) {\n  return new Promise(function (resolve, _) {\n    var blobUrl = URL.createObjectURL(blob);\n    var img = document.createElement('img');\n    img.src = blobUrl;\n\n    img.onload = function () {\n      resolve({\n        width: img.width,\n        height: img.height\n      });\n    };\n  });\n}\nexport function findImageInClipboardAsync(items) {\n  var _iterator, _step, clipboardItem;\n\n  return _regeneratorRuntime.async(function findImageInClipboardAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator = _createForOfIteratorHelperLoose(items);\n\n        case 1:\n          if ((_step = _iterator()).done) {\n            _context.next = 13;\n            break;\n          }\n\n          clipboardItem = _step.value;\n\n          if (!clipboardItem.types.some(function (type) {\n            return type === 'image/png';\n          })) {\n            _context.next = 7;\n            break;\n          }\n\n          _context.next = 6;\n          return _regeneratorRuntime.awrap(clipboardItem.getType('image/png'));\n\n        case 6:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 7:\n          if (!clipboardItem.types.some(function (type) {\n            return type === 'image/jpeg';\n          })) {\n            _context.next = 11;\n            break;\n          }\n\n          _context.next = 10;\n          return _regeneratorRuntime.awrap(clipboardItem.getType('image/jpeg'));\n\n        case 10:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 11:\n          _context.next = 1;\n          break;\n\n        case 13:\n          return _context.abrupt(\"return\", null);\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function findHtmlInClipboardAsync(items) {\n  var _iterator2, _step2, clipboardItem;\n\n  return _regeneratorRuntime.async(function findHtmlInClipboardAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _iterator2 = _createForOfIteratorHelperLoose(items);\n\n        case 1:\n          if ((_step2 = _iterator2()).done) {\n            _context2.next = 9;\n            break;\n          }\n\n          clipboardItem = _step2.value;\n\n          if (!clipboardItem.types.some(function (type) {\n            return type === 'text/html';\n          })) {\n            _context2.next = 7;\n            break;\n          }\n\n          _context2.next = 6;\n          return _regeneratorRuntime.awrap(clipboardItem.getType('text/html'));\n\n        case 6:\n          return _context2.abrupt(\"return\", _context2.sent);\n\n        case 7:\n          _context2.next = 1;\n          break;\n\n        case 9:\n          return _context2.abrupt(\"return\", null);\n\n        case 10:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function isClipboardPermissionDeniedAsync() {\n  var queryOpts, permissionStatus;\n  return _regeneratorRuntime.async(function isClipboardPermissionDeniedAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          queryOpts = {\n            name: 'clipboard-read'\n          };\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(navigator.permissions.query(queryOpts));\n\n        case 3:\n          permissionStatus = _context3.sent;\n          return _context3.abrupt(\"return\", permissionStatus.state === 'denied');\n\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../../src/web/Utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Converts base64-encoded data to a `Blob` object.\n * @see https://stackoverflow.com/a/20151856\n */\nexport function base64toBlob(base64Data: string, contentType: string): Blob {\n  contentType = contentType || '';\n  const sliceSize = 1024;\n  const byteCharacters = atob(base64Data);\n  const bytesLength = byteCharacters.length;\n  const slicesCount = Math.ceil(bytesLength / sliceSize);\n  const byteArrays = new Array(slicesCount);\n\n  for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\n    const begin = sliceIndex * sliceSize;\n    const end = Math.min(begin + sliceSize, bytesLength);\n\n    const bytes = new Array(end - begin);\n    for (let offset = begin, i = 0; offset < end; ++i, ++offset) {\n      bytes[i] = byteCharacters[offset].charCodeAt(0);\n    }\n    byteArrays[sliceIndex] = new Uint8Array(bytes);\n  }\n  // I cannot use `@ts-expect-error` here because some environments consider this correct:\n  // expo-module build - OK,\n  // expo-module test - error\n  // @ts-ignore `Blob` from `lib.dom.d.ts` and the one from `@types/react-native` differ somehow\n  return new Blob(byteArrays, { type: contentType });\n}\n\n/**\n * Converts blob to base64-encoded string with Data-URL prefix.\n */\nexport function blobToBase64Async(blob: Blob): Promise<string> {\n  return new Promise((resolve, _) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.readAsDataURL(blob);\n  });\n}\n\nexport function htmlToPlainText(html: string) {\n  const tempDivElement = document.createElement('div');\n  tempDivElement.innerHTML = html;\n  return tempDivElement.textContent || tempDivElement.innerText || '';\n}\n\nexport function getImageSizeFromBlobAsync(blob: Blob): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, _) => {\n    const blobUrl = URL.createObjectURL(blob);\n    const img = document.createElement('img');\n    img.src = blobUrl;\n    img.onload = function () {\n      resolve({ width: img.width, height: img.height });\n    };\n  });\n}\n\nexport async function findImageInClipboardAsync(items: ClipboardItems): Promise<Blob | null> {\n  for (const clipboardItem of items) {\n    // first look for png\n    if (clipboardItem.types.some((type) => type === 'image/png')) {\n      return await clipboardItem.getType('image/png');\n    }\n\n    // alternatively, an image might be a jpeg\n    // NOTE: Currently, this is not supported by browsers yet. They only support PNG now\n    if (clipboardItem.types.some((type) => type === 'image/jpeg')) {\n      return await clipboardItem.getType('image/jpeg');\n    }\n  }\n  return null;\n}\n\nexport async function findHtmlInClipboardAsync(items: ClipboardItems): Promise<Blob | null> {\n  for (const clipboardItem of items) {\n    if (clipboardItem.types.some((type) => type === 'text/html')) {\n      return await clipboardItem.getType('text/html');\n    }\n  }\n  return null;\n}\n\nexport async function isClipboardPermissionDeniedAsync(): Promise<boolean> {\n  const queryOpts = { name: 'clipboard-read' as PermissionName };\n  const permissionStatus = await navigator.permissions.query(queryOpts);\n  return permissionStatus.state === 'denied';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}